<!DOCTYPE html>
<html>
<head>
  <title>ONT ID Login Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .login-section {
      display: block;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      margin: 5px;
    }
    #logoutBtn {
      background-color: #f44336;
      display: none; /* Hidden by default */
    }
    button:hover {
      background-color: #45a049;
    }
    #logoutBtn:hover {
      background-color: #d32f2f;
    }
    #walletAddress {
      margin: 10px 0;
      font-weight: bold;
      display: none; /* Hidden by default */
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="loginSection" class="login-section">
      <h1>Login with ONT ID</h1>
      <div id="walletAddress"></div>
      <button id="loginBtn">Login</button>
      <button id="logoutBtn">Logout</button>
      <div id="result" style="margin-top:20px; font-weight: bold;"></div>
    </div>
  </div>

  <script>
    // UI elements
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const resultDiv = document.getElementById("result");
    const walletAddressDiv = document.getElementById("walletAddress");

    // Provider detection (MetaMask or ONTO Wallet)
    const provider = window.ethereum || window.onto;

    // Function to update UI based on login state
    function updateUI(isLoggedIn) {
      if (isLoggedIn) {
        loginBtn.textContent = "Connected";
        loginBtn.disabled = true;
        loginBtn.style.backgroundColor = "#888";
        logoutBtn.style.display = "inline-block";
        const walletAddress = localStorage.getItem("walletAddress");
        if (walletAddress) {
          walletAddressDiv.textContent = `Wallet Address: ${walletAddress}`;
          walletAddressDiv.style.display = "block";
        }
        resultDiv.innerHTML = "✅ Logged in";
      } else {
        loginBtn.textContent = "Login";
        loginBtn.disabled = false;
        loginBtn.style.backgroundColor = "#4CAF50";
        logoutBtn.style.display = "none";
        walletAddressDiv.textContent = "";
        walletAddressDiv.style.display = "none";
        resultDiv.innerHTML = "";
      }
    }

    // Check login state on page load
    const isLoggedIn = localStorage.getItem("isLoggedIn") === "true";
    updateUI(isLoggedIn);

    // Global function to sign data with fallback methods
    window.signData = function(account, signData) {
      return new Promise((resolve, reject) => {
        const methods = ['eth_signTypedData_v4', 'eth_signTypedData_v3', 'eth_signTypedData'];
        let methodIndex = 0;

        function tryNextMethod() {
          if (methodIndex >= methods.length) {
            // Fallback to eth_sign
            console.log("Falling back to eth_sign...");
            const message = `Login to ONT ID Demo: ${signData.message.nonce}`;
            provider.request({
              method: 'eth_sign',
              params: [account, message]
            })
            .then(signature => {
              console.log("Signed successfully with eth_sign");
              resolve({ signature, method: 'eth_sign' });
            })
            .catch(error => {
              console.warn(`eth_sign failed: ${error.message}`);
              reject(new Error('No supported signing method found. Ensure your wallet supports EIP-712 or eth_sign.'));
            });
            return;
          }

          const method = methods[methodIndex];
          console.log(`Attempting to sign with ${method}...`);
          provider.request({
            method,
            params: [account, JSON.stringify(signData)]
          })
          .then(signature => {
            console.log(`Signed successfully with ${method}`);
            resolve({ signature, method });
          })
          .catch(error => {
            console.warn(`Method ${method} failed: ${error.message}`);
            methodIndex++;
            tryNextMethod();
          });
        }

        tryNextMethod();
      });
    };

    loginBtn.addEventListener("click", async () => {
      try {
        if (!provider) {
          throw new Error("No Ethereum provider found. Install MetaMask or ONTO Wallet.");
        }

        // Log provider details for debugging
        console.log("Provider detected:", {
          isONTO: !!window.onto,
          isMetaMask: !!provider.isMetaMask,
          providerProperties: Object.keys(provider),
          supportsRequest: typeof provider.request === 'function'
        });

        // 1. Create auth request
        console.log("Creating auth request...");
        const authRequest = {
          type: "AuthRequest",
          chain: "eth",
          app: "ONT ID Demo App",
          name: "ONT ID Demo",
          version: "1.0",
          challenge: "login-challenge",
          domain: window.location.hostname,
          issuer: "did:ont:issuer",
          requestId: Date.now().toString(),
          callbackUrl: `${window.location.protocol}//${window.location.host}/submit-auth`
        };
        console.log("Auth request created:", authRequest);

        // 2. Get challenge from backend
        console.log("Fetching challenge...");
        const challengeResponse = await fetch("/get-challenge", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ authRequest })
        });
        if (!challengeResponse.ok) {
          const errorText = await challengeResponse.text();
          throw new Error(`Challenge fetch failed: ${challengeResponse.statusText} - ${errorText}`);
        }
        const challenge = await challengeResponse.json();
        console.log("Challenge received:", challenge);

        // 3. Request accounts
        console.log("Requesting accounts...");
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        const account = accounts[0];
        console.log("Account:", account);

        // 4. Build DID
        const did = `did:etho:${account.replace("0x", "")}`;
        console.log("DID:", did);

        // 5. Prepare sign data
        console.log("Creating sign data...");
        const signData = {
          types: {
            EIP712Domain: [
              { name: "name", type: "string" },
              { name: "version", type: "string" },
              { name: "chainId", type: "uint256" },
              { name: "verifyingContract", type: "address" }
            ],
            AuthChallenge: [
              { name: "nonce", type: "string" },
              { name: "did", type: "string" },
              { name: "created", type: "string" }
            ]
          },
          domain: {
            name: "ONT ID Demo",
            version: "1.0",
            chainId: 1, // Ethereum mainnet; adjust for testnet (e.g., 11155111 for Sepolia)
            verifyingContract: "0x0000000000000000000000000000000000000000"
          },
          primaryType: "AuthChallenge",
          message: {
            nonce: challenge.nonce,
            did,
            created: new Date().toISOString()
          }
        };
        console.log("Sign data:", signData);

        // 6. Sign using wallet
        console.log("Signing data...");
        if (typeof window.signData !== 'function') {
          throw new Error("signData function is not defined. Please check the script loading.");
        }
        const { signature, method } = await window.signData(account, signData);
        console.log("Signature:", signature, "Method:", method);

        // 7. Build auth response
        const authResponse = {
          ver: "1.0",
          type: "ClientResponse",
          nonce: challenge.nonce,
          did,
          proof: {
            type: method === 'eth_sign' ? 'eth_sign' : 'ecdsa',
            verificationMethod: `${did}#key-1`,
            created: signData.message.created,
            value: signature
          },
          VPs: []
        };
        console.log("Auth response:", authResponse);

        // 8. Submit to backend
        console.log("Submitting auth response...");
        const resultResponse = await fetch("/submit-auth", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(authResponse)
        });
        if (!challengeResponse.ok) {
          const errorText = await resultResponse.text();
          throw new Error(`Submit auth failed: ${resultResponse.statusText} - ${errorText}`);
        }
        const result = await resultResponse.json();
        if (result.error) {
          throw new Error(`Login failed: ${result.error}`);
        }
        console.log("Login result:", result);

        // 9. Save login state and wallet address, then update UI
        localStorage.setItem("isLoggedIn", "true");
        localStorage.setItem("walletAddress", account);
        updateUI(true);
      } catch (error) {
        console.error("Login error:", error);
        resultDiv.innerHTML = `❌ Login failed: ${error.message}`;
      }
    });

    logoutBtn.addEventListener("click", async () => {
      try {
        console.log("Logging out...");
        await fetch("/logout", { method: "POST" });
        localStorage.removeItem("isLoggedIn");
        localStorage.removeItem("walletAddress");
        updateUI(false);
      } catch (error) {
        console.error("Logout error:", error);
        resultDiv.innerHTML = `❌ Logout failed: ${error.message}`;
      }
    });
  </script>
</body>
</html>